use strict;
use v5.36;

use File::Copy qw(copy);
use File::Path qw(make_path);
use File::Temp qw(tempdir tempfile);
use JSON::PP qw(decode_json);
use Test::More;

my $cli = "scripts/cna";

my @cases = (
  "CVE-2025-40916",
  "CVE-2025-40933",
);

for my $id (@cases) {
  my $source_path = "t/var/$id.source.json";
  my $yaml_path   = "t/var/$id.yaml";

  ok(-f $source_path, "$id source fixture exists");
  ok(-f $yaml_path, "$id yaml fixture exists");

  my $source_doc = read_json_file($source_path);
  my $generated_doc = generate_from_yaml($id, $yaml_path);

  my $source_projection = project_roundtrip_view($source_doc);
  my $generated_projection = project_roundtrip_view($generated_doc);

  is_deeply(
    $generated_projection,
    $source_projection,
    "$id YAML -> JSON matches source on schema-representable fields",
  );
}

done_testing();

sub generate_from_yaml ($id, $yaml_path) {
  my $root = tempdir(CLEANUP => 1);
  my $cves = "$root/cves";
  make_path($cves);
  my $target = "$cves/$id.yaml";
  copy($yaml_path, $target) or die "Cannot copy $yaml_path -> $target: $!";
  my ($err_fh, $err) = tempfile();
  close($err_fh);

  my $json = qx($cli --cpansec-cna-root '$root' emit $id 2>'$err');
  my $exit = $? >> 8;
  die "cna emit failed for $id with exit code $exit: $json\n" if $exit != 0;
  return decode_json($json);
}

sub read_json_file ($path) {
  open(my $fh, "<", $path) or die "Cannot read $path: $!";
  local $/;
  my $json = <$fh>;
  close($fh);
  return decode_json($json);
}

sub project_roundtrip_view ($doc) {
  my $cna = $doc->{containers}->{cna};
  my $affected = $cna->{affected}->[0] // {};

  return {
    cve => $doc->{cveMetadata}->{cveId},
    distribution => $affected->{packageName},
    module => $affected->{product},
    author => $affected->{vendor},
    repo => $affected->{repo},
    affected => [
      map { normalize_version_entry($_) } @{$affected->{versions} // []}
    ],
    files => [ sort @{$affected->{programFiles} // []} ],
    routines => [
      sort map { $_->{name} } @{$affected->{programRoutines} // []}
    ],
    title => normalize_ws($cna->{title} // ""),
    description => normalize_ws(first_en_value($cna->{descriptions})),
    cwes => [
      sort map { normalize_ws($_) } extract_cwe_descriptions($cna->{problemTypes}),
    ],
    solution => [ map { normalize_ws($_) } @{$cna->{solutions} ? [ map { $_->{value} // "" } @{$cna->{solutions}} ] : []} ],
    mitigation => [ map { normalize_ws($_) } @{$cna->{workarounds} ? [ map { $_->{value} // "" } @{$cna->{workarounds}} ] : []} ],
    references => [
      map { normalize_reference($_) }
      sort { ($a->{url} // "") cmp ($b->{url} // "") } @{$cna->{references} // []}
    ],
  };
}

sub normalize_version_entry ($v) {
  return {
    versionType => $v->{versionType},
    status => $v->{status},
    version => $v->{version},
    (exists $v->{lessThan} ? (lessThan => $v->{lessThan}) : ()),
    (exists $v->{lessThanOrEqual} ? (lessThanOrEqual => $v->{lessThanOrEqual}) : ()),
  };
}

sub extract_cwe_descriptions ($problem_types) {
  my @out;
  for my $pt (@{$problem_types // []}) {
    for my $d (@{$pt->{descriptions} // []}) {
      next unless defined $d->{description};
      push @out, $d->{description};
    }
  }
  return @out;
}

sub normalize_reference ($r) {
  return {
    link => $r->{url},
    (exists $r->{tags} ? (tags => [ sort @{$r->{tags}} ]) : ()),
  };
}

sub first_en_value ($entries) {
  for my $e (@{$entries // []}) {
    return $e->{value} // "" if ($e->{lang} // "") eq "en";
  }
  return "";
}

sub normalize_ws ($text) {
  $text //= "";
  $text =~ s/\r\n?/\n/g;
  $text =~ s/\s+/ /g;
  $text =~ s/^\s+//;
  $text =~ s/\s+$//;
  return $text;
}
